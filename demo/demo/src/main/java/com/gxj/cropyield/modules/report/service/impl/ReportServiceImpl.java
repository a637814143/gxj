package com.gxj.cropyield.modules.report.service.impl;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.gxj.cropyield.common.exception.BusinessException;
import com.gxj.cropyield.common.response.ResultCode;
import com.gxj.cropyield.modules.base.entity.Crop;
import com.gxj.cropyield.modules.base.entity.Region;
import com.gxj.cropyield.modules.base.repository.CropRepository;
import com.gxj.cropyield.modules.base.repository.RegionRepository;
import com.gxj.cropyield.modules.dataset.entity.PriceRecord;
import com.gxj.cropyield.modules.dataset.entity.YieldRecord;
import com.gxj.cropyield.modules.dataset.repository.PriceRecordRepository;
import com.gxj.cropyield.modules.dataset.repository.YieldRecordRepository;
import com.gxj.cropyield.modules.forecast.entity.ForecastResult;
import com.gxj.cropyield.modules.forecast.repository.ForecastResultRepository;
import com.gxj.cropyield.modules.report.dto.ReportDetailResponse;
import com.gxj.cropyield.modules.report.dto.ReportGenerationRequest;
import com.gxj.cropyield.modules.report.dto.ReportMetrics;
import com.gxj.cropyield.modules.report.dto.ReportOverviewResponse;
import com.gxj.cropyield.modules.report.dto.ReportRequest;
import com.gxj.cropyield.modules.report.dto.ReportSectionResponse;
import com.gxj.cropyield.modules.report.dto.ReportSummaryResponse;
import com.gxj.cropyield.modules.report.entity.Report;
import com.gxj.cropyield.modules.report.entity.ReportSection;
import com.gxj.cropyield.modules.report.repository.ReportRepository;
import com.gxj.cropyield.modules.report.service.ReportService;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.YearMonth;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.DoubleSummaryStatistics;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
/**
 * 报表分析模块的业务实现类，负责落实报表分析领域的业务处理逻辑。
 * <p>核心方法：getOverview、create、generate、getDetail、toDetail、toSummary、buildSection、toSectionResponse。</p>
 */

@Service
public class ReportServiceImpl implements ReportService {

    private final ReportRepository reportRepository;
    private final ForecastResultRepository forecastResultRepository;
    private final RegionRepository regionRepository;
    private final CropRepository cropRepository;
    private final YieldRecordRepository yieldRecordRepository;
    private final PriceRecordRepository priceRecordRepository;
    private final ObjectMapper objectMapper;

    public ReportServiceImpl(ReportRepository reportRepository,
                             ForecastResultRepository forecastResultRepository,
                             RegionRepository regionRepository,
                             CropRepository cropRepository,
                             YieldRecordRepository yieldRecordRepository,
                             PriceRecordRepository priceRecordRepository,
                             ObjectMapper objectMapper) {
        this.reportRepository = reportRepository;
        this.forecastResultRepository = forecastResultRepository;
        this.regionRepository = regionRepository;
        this.cropRepository = cropRepository;
        this.yieldRecordRepository = yieldRecordRepository;
        this.priceRecordRepository = priceRecordRepository;
        this.objectMapper = objectMapper;
    }

    @Override
    public ReportOverviewResponse getOverview() {
        List<Report> reports = reportRepository.findAll(Sort.by(Sort.Direction.DESC, "publishedAt", "createdAt"));
        List<ReportSummaryResponse> summaries = reports.stream()
            .map(this::toSummary)
            .collect(Collectors.toList());

        YearMonth currentMonth = YearMonth.now();
        long publishedThisMonth = reports.stream()
            .filter(report -> report.getPublishedAt() != null)
            .filter(report -> YearMonth.from(report.getPublishedAt()).equals(currentMonth))
            .filter(report -> "PUBLISHED".equalsIgnoreCase(report.getStatus()))
            .count();

        long pendingApproval = reports.stream()
            .filter(report -> "PENDING".equalsIgnoreCase(report.getStatus()))
            .count();

        boolean autoGenerationEnabled = reports.stream().anyMatch(Report::isAutoGenerated);

        return new ReportOverviewResponse(
            summaries,
            new ReportMetrics(reports.size(), publishedThisMonth, pendingApproval, autoGenerationEnabled)
        );
    }

    @Override
    @Transactional
    public Report create(ReportRequest request) {
        ForecastResult result = forecastResultRepository.findById(request.forecastResultId())
            .orElseThrow(() -> new BusinessException(ResultCode.NOT_FOUND, "预测结果不存在"));

        Report report = new Report();
        report.setTitle(request.title());
        report.setDescription(request.description());
        report.setAuthor(StringUtils.hasText(request.author()) ? request.author().trim() : "系统自动");
        report.setCoveragePeriod(StringUtils.hasText(request.coveragePeriod()) ? request.coveragePeriod().trim() : null);
        report.setForecastResult(result);
        report.setInsights(request.insights());
        report.setStatus(StringUtils.hasText(request.status()) ? request.status().trim() : "PUBLISHED");
        report.setPublishedAt(request.publishedAt() != null ? request.publishedAt() : LocalDateTime.now());
        report.setAutoGenerated(Boolean.TRUE.equals(request.autoGenerated()));
        return reportRepository.save(report);
    }

    @Override
    @Transactional
    public ReportDetailResponse generate(ReportGenerationRequest request) {
        Region region = regionRepository.findById(request.regionId())
            .orElseThrow(() -> new BusinessException(ResultCode.NOT_FOUND, "分析区域不存在"));
        Crop crop = cropRepository.findById(request.cropId())
            .orElseThrow(() -> new BusinessException(ResultCode.NOT_FOUND, "农作物不存在"));

        List<YieldRecord> historicalRecords = yieldRecordRepository.findByRegionIdAndCropIdOrderByYearAsc(region.getId(), crop.getId());
        if (CollectionUtils.isEmpty(historicalRecords)) {
            throw new BusinessException(ResultCode.BAD_REQUEST, "所选条件暂无历史产量数据，无法生成报告");
        }

        int minYear = historicalRecords.stream()
            .map(YieldRecord::getYear)
            .filter(Objects::nonNull)
            .min(Integer::compareTo)
            .orElseThrow(() -> new BusinessException(ResultCode.SERVER_ERROR, "历史数据缺失年份信息"));
        int maxYear = historicalRecords.stream()
            .map(YieldRecord::getYear)
            .filter(Objects::nonNull)
            .max(Integer::compareTo)
            .orElseThrow(() -> new BusinessException(ResultCode.SERVER_ERROR, "历史数据缺失年份信息"));

        int requestedStart = request.startYear() != null ? request.startYear() : minYear;
        int requestedEnd = request.endYear() != null ? request.endYear() : maxYear;
        if (requestedStart > requestedEnd) {
            throw new BusinessException(ResultCode.BAD_REQUEST, "开始年份不能晚于结束年份");
        }

        int startYear = Math.max(minYear, requestedStart);
        int endYear = Math.min(maxYear, requestedEnd);

        List<YieldRecord> filteredRecords = historicalRecords.stream()
            .filter(record -> record.getYear() != null)
            .filter(record -> record.getYear() >= startYear && record.getYear() <= endYear)
            .sorted(Comparator.comparing(YieldRecord::getYear))
            .toList();

        if (filteredRecords.isEmpty()) {
            throw new BusinessException(ResultCode.BAD_REQUEST, "所选年份范围内缺少产量数据");
        }

        DoubleSummaryStatistics yieldStats = filteredRecords.stream()
            .map(YieldRecord::getYieldPerHectare)
            .filter(Objects::nonNull)
            .mapToDouble(Double::doubleValue)
            .summaryStatistics();

        DoubleSummaryStatistics productionStats = filteredRecords.stream()
            .map(YieldRecord::getProduction)
            .filter(Objects::nonNull)
            .mapToDouble(Double::doubleValue)
            .summaryStatistics();

        DoubleSummaryStatistics sownAreaStats = filteredRecords.stream()
            .map(YieldRecord::getSownArea)
            .filter(Objects::nonNull)
            .mapToDouble(Double::doubleValue)
            .summaryStatistics();

        YieldRecord latestRecord = filteredRecords.get(filteredRecords.size() - 1);
        YieldRecord previousRecord = filteredRecords.size() > 1 ? filteredRecords.get(filteredRecords.size() - 2) : null;
        Double yieldYoY = computeYoY(latestRecord.getYieldPerHectare(), previousRecord != null ? previousRecord.getYieldPerHectare() : null);
        Double productionYoY = computeYoY(latestRecord.getProduction(), previousRecord != null ? previousRecord.getProduction() : null);

        Optional<YieldRecord> bestYieldRecord = filteredRecords.stream()
            .filter(record -> record.getYieldPerHectare() != null)
            .max(Comparator.comparing(YieldRecord::getYieldPerHectare));

        ForecastResult forecastResult = resolveForecastResult(request, crop.getId(), region.getId());
        Double actualYieldForForecastYear = null;
        if (forecastResult != null) {
            actualYieldForForecastYear = yieldRecordRepository.findByCropIdAndRegionIdAndYear(crop.getId(), region.getId(), forecastResult.getTargetYear())
                .map(YieldRecord::getYieldPerHectare)
                .orElse(null);
        }

        List<PriceRecord> priceRecords = List.of();
        if (Boolean.TRUE.equals(request.includePriceAnalysis())) {
            LocalDate priceStart = LocalDate.of(startYear, 1, 1);
            LocalDate priceEnd = LocalDate.of(endYear, 12, 31);
            priceRecords = priceRecordRepository.findByRegionIdAndCropIdAndRecordDateBetweenOrderByRecordDateAsc(
                region.getId(), crop.getId(), priceStart, priceEnd
            );
        }

        Double averagePrice = priceRecords.stream()
            .map(PriceRecord::getPrice)
            .filter(Objects::nonNull)
            .mapToDouble(Double::doubleValue)
            .average()
            .orElse(Double.NaN);
        if (Double.isNaN(averagePrice)) {
            averagePrice = null;
        }

        String title = StringUtils.hasText(request.title())
            ? request.title().trim()
            : String.format(Locale.CHINA, "%s%s产量分析报告", region.getName(), crop.getName());
        String coverage = startYear == endYear
            ? String.format(Locale.CHINA, "%d年", startYear)
            : String.format(Locale.CHINA, "%d-%d年", startYear, endYear);
        String description = StringUtils.hasText(request.description())
            ? request.description().trim()
            : String.format(Locale.CHINA, "%s%s %s 农情与市场研判", region.getName(), crop.getName(), coverage);

        List<String> highlights = buildHighlights(yieldStats, productionStats, yieldYoY, productionYoY, bestYieldRecord.orElse(null),
            averagePrice, forecastResult, actualYieldForForecastYear);
        String insights = highlights.isEmpty() ? null : String.join("；", highlights);

        Report report = new Report();
        report.setTitle(title);
        report.setDescription(description);
        report.setAuthor(StringUtils.hasText(request.author()) ? request.author().trim() : "系统自动");
        report.setCoveragePeriod(coverage);
        report.setForecastResult(forecastResult);
        report.setInsights(insights);
        report.setStatus("PUBLISHED");
        report.setPublishedAt(LocalDateTime.now());
        report.setAutoGenerated(true);

        int order = 1;
        report.addSection(buildSection("OVERVIEW", "核心指标概览", "历史产量与关键指标一览",
            buildOverviewData(region, crop, startYear, endYear, filteredRecords, yieldStats, productionStats, sownAreaStats,
                yieldYoY, productionYoY, averagePrice, highlights), order++));

        report.addSection(buildSection("YIELD_TREND", "历年产量趋势", "按年度展示播种面积、总产量与单产变化",
            buildYieldTrendData(filteredRecords), order++));

        if (!priceRecords.isEmpty()) {
            report.addSection(buildSection("PRICE_TREND", "市场价格走势", "结合历史价格观察市场波动",
                buildPriceTrendData(priceRecords, averagePrice), order++));
        }

        if (forecastResult != null) {
            report.addSection(buildSection("FORECAST_COMPARISON", "预测结果对比", "对比预测与实际表现，评估模型效果",
                buildForecastComparisonData(forecastResult, actualYieldForForecastYear), order));
        }

        Report saved = reportRepository.save(report);
        return getDetail(saved.getId());
    }

    @Override
    @Transactional(readOnly = true)
    public ReportDetailResponse getDetail(Long id) {
        Report report = reportRepository.findWithSectionsById(id)
            .orElseThrow(() -> new BusinessException(ResultCode.NOT_FOUND, "报告不存在"));
        return toDetail(report);
    }

    private ReportDetailResponse toDetail(Report report) {
        List<ReportSectionResponse> sections = report.getSections().stream()
            .sorted(Comparator.comparing(ReportSection::getSortOrder, Comparator.nullsLast(Integer::compareTo))
                .thenComparing(ReportSection::getId, Comparator.nullsLast(Long::compareTo)))
            .map(this::toSectionResponse)
            .toList();
        return new ReportDetailResponse(toSummary(report), sections);
    }

    private ReportSummaryResponse toSummary(Report report) {
        return new ReportSummaryResponse(
            report.getId(),
            report.getTitle(),
            report.getDescription(),
            report.getAuthor(),
            report.getCoveragePeriod(),
            report.getStatus(),
            report.isAutoGenerated(),
            report.getPublishedAt(),
            report.getInsights()
        );
    }

    private ReportSection buildSection(String type, String title, String description, Object data, int sortOrder) {
        ReportSection section = new ReportSection();
        section.setType(type);
        section.setTitle(title);
        section.setDescription(description);
        section.setSortOrder(sortOrder);
        section.setData(toJsonString(data));
        return section;
    }

    private ReportSectionResponse toSectionResponse(ReportSection section) {
        return new ReportSectionResponse(
            section.getId(),
            section.getType(),
            section.getTitle(),
            section.getDescription(),
            toJsonNode(section.getData()),
            section.getSortOrder()
        );
    }

    private String toJsonString(Object data) {
        try {
            return objectMapper.writeValueAsString(data);
        } catch (JsonProcessingException e) {
            throw new BusinessException(ResultCode.SERVER_ERROR, "生成报告内容时出现异常");
        }
    }

    private JsonNode toJsonNode(String json) {
        if (!StringUtils.hasText(json)) {
            return objectMapper.createObjectNode();
        }
        try {
            return objectMapper.readTree(json);
        } catch (JsonProcessingException e) {
            ObjectNode fallback = objectMapper.createObjectNode();
            fallback.put("raw", json);
            return fallback;
        }
    }

    private Double computeYoY(Double current, Double previous) {
        if (current == null || previous == null || Math.abs(previous) < 1e-6) {
            return null;
        }
        return (current - previous) / previous * 100.0;
    }

    private Double round(Double value, int scale) {
        if (value == null) {
            return null;
        }
        return BigDecimal.valueOf(value)
            .setScale(scale, RoundingMode.HALF_UP)
            .doubleValue();
    }

    private Map<String, Object> buildOverviewData(Region region,
                                                  Crop crop,
                                                  int startYear,
                                                  int endYear,
                                                  List<YieldRecord> records,
                                                  DoubleSummaryStatistics yieldStats,
                                                  DoubleSummaryStatistics productionStats,
                                                  DoubleSummaryStatistics sownAreaStats,
                                                  Double yieldYoY,
                                                  Double productionYoY,
                                                  Double averagePrice,
                                                  List<String> highlights) {
        Map<String, Object> data = new LinkedHashMap<>();
        data.put("region", region.getName());
        data.put("crop", crop.getName());
        Map<String, Object> range = new LinkedHashMap<>();
        range.put("start", startYear);
        range.put("end", endYear);
        range.put("years", records.size());
        data.put("yearRange", range);

        List<Map<String, Object>> metrics = new ArrayList<>();
        if (yieldStats.getCount() > 0) {
            metrics.add(metric("平均单产", round(yieldStats.getAverage(), 2), "吨/公顷"));
        }
        if (productionStats.getCount() > 0) {
            metrics.add(metric("平均总产量", round(productionStats.getAverage(), 2), "万吨"));
        }
        if (sownAreaStats.getCount() > 0) {
            metrics.add(metric("平均播种面积", round(sownAreaStats.getAverage(), 2), "千公顷"));
        }
        if (yieldYoY != null) {
            metrics.add(metric("单产同比", round(yieldYoY, 2), "%"));
        }
        if (productionYoY != null) {
            metrics.add(metric("总产同比", round(productionYoY, 2), "%"));
        }
        if (averagePrice != null) {
            metrics.add(metric("平均价格", round(averagePrice, 2), "元/吨"));
        }
        data.put("metrics", metrics);
        data.put("highlights", highlights);
        return data;
    }

    private Map<String, Object> metric(String label, Double value, String unit) {
        Map<String, Object> metric = new LinkedHashMap<>();
        metric.put("label", label);
        metric.put("value", value);
        metric.put("unit", unit);
        return metric;
    }

    private Map<String, Object> buildYieldTrendData(List<YieldRecord> records) {
        Map<String, Object> data = new LinkedHashMap<>();
        List<Map<String, Object>> series = records.stream()
            .map(record -> {
                Map<String, Object> entry = new LinkedHashMap<>();
                entry.put("year", record.getYear());
                entry.put("yieldPerHectare", record.getYieldPerHectare());
                entry.put("production", record.getProduction());
                entry.put("sownArea", record.getSownArea());
                entry.put("averagePrice", record.getAveragePrice());
                return entry;
            })
            .toList();
        data.put("series", series);
        return data;
    }

    private Map<String, Object> buildPriceTrendData(List<PriceRecord> priceRecords, Double averagePrice) {
        Map<String, Object> data = new LinkedHashMap<>();
        List<Map<String, Object>> series = priceRecords.stream()
            .map(record -> {
                Map<String, Object> entry = new LinkedHashMap<>();
                entry.put("date", record.getRecordDate());
                entry.put("price", record.getPrice());
                return entry;
            })
            .toList();
        data.put("series", series);
        data.put("averagePrice", averagePrice);
        data.put("unit", "元/吨");
        return data;
    }

    private Map<String, Object> buildForecastComparisonData(ForecastResult forecastResult, Double actualYield) {
        Map<String, Object> data = new LinkedHashMap<>();
        data.put("forecastYear", forecastResult.getTargetYear());
        data.put("predictedYield", forecastResult.getPredictedYield());
        data.put("predictedProduction", forecastResult.getPredictedProduction());
        data.put("measurementValue", forecastResult.getMeasurementValue());
        data.put("measurementLabel", forecastResult.getMeasurementLabel());
        data.put("measurementUnit", forecastResult.getMeasurementUnit());
        data.put("evaluation", forecastResult.getEvaluation());
        data.put("actualYield", actualYield);
        Double difference = null;
        if (actualYield != null && forecastResult.getPredictedYield() != null) {
            difference = round(forecastResult.getPredictedYield() - actualYield, 2);
        }
        data.put("difference", difference);
        Map<String, Object> taskInfo = new LinkedHashMap<>();
        taskInfo.put("taskId", forecastResult.getTask().getId());
        taskInfo.put("model", forecastResult.getTask().getModel().getName());
        taskInfo.put("modelType", forecastResult.getTask().getModel().getType().name());
        taskInfo.put("region", forecastResult.getTask().getRegion().getName());
        taskInfo.put("crop", forecastResult.getTask().getCrop().getName());
        data.put("task", taskInfo);
        return data;
    }

    private List<String> buildHighlights(DoubleSummaryStatistics yieldStats,
                                         DoubleSummaryStatistics productionStats,
                                         Double yieldYoY,
                                         Double productionYoY,
                                         YieldRecord bestYieldRecord,
                                         Double averagePrice,
                                         ForecastResult forecastResult,
                                         Double actualYieldForForecastYear) {
        List<String> highlights = new ArrayList<>();
        if (yieldStats.getCount() > 0) {
            highlights.add(String.format(Locale.CHINA, "平均单产 %.2f 吨/公顷", yieldStats.getAverage()));
        }
        if (productionStats.getCount() > 0) {
            highlights.add(String.format(Locale.CHINA, "平均总产量 %.2f 万吨", productionStats.getAverage()));
        }
        if (yieldYoY != null) {
            highlights.add(String.format(Locale.CHINA, "最近一年单产同比%s%.2f%%", yieldYoY >= 0 ? "增长" : "下降", Math.abs(yieldYoY)));
        }
        if (productionYoY != null) {
            highlights.add(String.format(Locale.CHINA, "最近一年总产量同比%s%.2f%%", productionYoY >= 0 ? "增长" : "下降", Math.abs(productionYoY)));
        }
        if (bestYieldRecord != null && bestYieldRecord.getYieldPerHectare() != null) {
            highlights.add(String.format(Locale.CHINA, "%d 年达到最高单产 %.2f 吨/公顷", bestYieldRecord.getYear(), bestYieldRecord.getYieldPerHectare()));
        }
        if (averagePrice != null) {
            highlights.add(String.format(Locale.CHINA, "同期平均价格约 %.2f 元/吨", averagePrice));
        }
        if (forecastResult != null) {
            Double predictedYield = forecastResult.getPredictedYield();
            if (predictedYield != null) {
                if (actualYieldForForecastYear != null) {
                    double diff = predictedYield - actualYieldForForecastYear;
                    highlights.add(String.format(Locale.CHINA, "预测 %d 年单产 %.2f 吨/公顷，较实际偏差 %.2f 吨/公顷",
                        forecastResult.getTargetYear(), predictedYield, diff));
                } else {
                    highlights.add(String.format(Locale.CHINA, "预测 %d 年单产 %.2f 吨/公顷，建议关注后续实际表现",
                        forecastResult.getTargetYear(), predictedYield));
                }
            } else if (forecastResult.getMeasurementValue() != null) {
                String label = StringUtils.hasText(forecastResult.getMeasurementLabel())
                    ? forecastResult.getMeasurementLabel()
                    : "预测值";
                String unit = StringUtils.hasText(forecastResult.getMeasurementUnit())
                    ? " " + forecastResult.getMeasurementUnit()
                    : "";
                highlights.add(String.format(Locale.CHINA, "预测 %d 年%s %.2f%s，建议关注后续实际表现",
                    forecastResult.getTargetYear(), label, forecastResult.getMeasurementValue(), unit));
            }
        }
        return highlights;
    }

    private ForecastResult resolveForecastResult(ReportGenerationRequest request, Long cropId, Long regionId) {
        if (!Boolean.TRUE.equals(request.includeForecastComparison()) || request.forecastResultId() == null) {
            return null;
        }
        ForecastResult result = forecastResultRepository.findById(request.forecastResultId())
            .orElseThrow(() -> new BusinessException(ResultCode.NOT_FOUND, "预测结果不存在"));
        if (!Objects.equals(result.getTask().getCrop().getId(), cropId)
            || !Objects.equals(result.getTask().getRegion().getId(), regionId)) {
            throw new BusinessException(ResultCode.BAD_REQUEST, "预测结果与所选区域或作物不匹配");
        }
        return result;
    }
}
