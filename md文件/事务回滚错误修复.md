# 事务回滚错误修复说明

## 问题1: 事务回滚错误

### 问题描述
管理员重置用户密码时出现错误：
```
Transaction silently rolled back because it has been marked as rollback-only
```

### 根本原因

### 问题链路
1. `UserServiceImpl.updatePassword()` 方法使用了 `@Transactional` 注解
2. 方法内调用 `emailNotificationService.sendEmailNotification()` 发送邮件
3. `EmailNotificationServiceImpl` 调用 `emailSender.sendHtmlAsync().join()` **阻塞等待**异步邮件发送完成
4. 如果邮件发送失败，抛出异常
5. 异常被 try-catch 捕获并重新抛出
6. 事务被标记为 rollback-only
7. Spring 尝试提交事务时发现已被标记回滚，报错

### 核心问题
**在事务内阻塞等待异步操作完成**，违反了异步设计的初衷，且异步操作的失败会污染事务状态。

## 解决方案

### 1. 修改 EmailNotificationServiceImpl
**文件**: `demo/src/main/java/com/gxj/cropyield/modules/notification/service/impl/EmailNotificationServiceImpl.java`

**修改前**:
```java
String html = renderTemplate(template, subject, context);
try {
    emailSender.sendHtmlAsync(to, subject, html).join(); // 阻塞等待
} catch (CompletionException ex) {
    // 抛出异常，污染事务
    throw new BusinessException(ResultCode.SERVER_ERROR, "邮件发送失败");
}
```

**修改后**:
```java
String html = renderTemplate(template, subject, context);
// 异步发送邮件，不等待结果，避免阻塞事务
emailSender.sendHtmlAsync(to, subject, html)
    .exceptionally(ex -> {
        log.error("Failed to send notification email to {}: {}", to, ex.getMessage(), ex);
        return null;
    });
log.info("邮件发送任务已提交 - 收件人: {}, 主题: {}", to, subject);
```

**改进点**:
- 移除 `.join()` 调用，不再阻塞等待
- 使用 `.exceptionally()` 异步处理失败情况
- 邮件发送失败不影响主业务流程（密码重置）

### 2. 简化 UserServiceImpl.updatePassword()
**文件**: `demo/src/main/java/com/gxj/cropyield/modules/auth/service/impl/UserServiceImpl.java`

**修改前**:
```java
try {
    // ... 密码重置逻辑
    if (!StringUtils.hasText(email)) {
        throw new BusinessException(ResultCode.BAD_REQUEST, "用户未绑定邮箱");
    }
    emailNotificationService.sendEmailNotification(...);
} catch (Exception e) {
    log.error("用户密码重置失败 - ID: {}, 错误: {}", userId, e.getMessage());
    throw e;
}
```

**修改后**:
```java
// ... 密码重置逻辑
if (!StringUtils.hasText(email)) {
    log.warn("用户未绑定邮箱，无法发送重置密码通知 - ID: {}, 用户名: {}", userId, user.getUsername());
} else {
    emailNotificationService.sendEmailNotification(...);
}
log.info("用户密码重置成功 - ID: {}, 用户名: {}", userId, user.getUsername());
```

**改进点**:
- 移除不必要的 try-catch 块
- 用户未绑定邮箱时记录警告而非抛出异常
- 邮件发送不再影响密码重置的成功与否

## 设计原则

### 异步操作与事务隔离
1. **事务内不应阻塞等待异步操作**
   - 异步操作应该"发射后不管"（fire-and-forget）
   - 使用 `@Async` 的方法返回 `CompletableFuture` 后立即返回

2. **非关键操作不应影响主流程**
   - 邮件发送是通知性质，失败不应导致密码重置失败
   - 使用日志记录失败情况，便于后续排查

3. **异常处理策略**
   - 关键业务异常：抛出，触发事务回滚
   - 非关键操作异常：记录日志，不影响主流程

## 测试验证

### 测试场景
1. **正常场景**: 用户有邮箱，邮件发送成功
   - 密码重置成功
   - 邮件发送成功
   - 事务正常提交

2. **邮件发送失败**: 邮件服务器故障
   - 密码重置成功
   - 邮件发送失败（后台日志记录）
   - 事务正常提交

3. **用户无邮箱**: 用户未绑定邮箱
   - 密码重置成功
   - 记录警告日志
   - 事务正常提交

### 预期结果
所有场景下密码重置都应成功，不再出现事务回滚错误。

## 相关文件
- `demo/src/main/java/com/gxj/cropyield/modules/auth/service/impl/UserServiceImpl.java`
- `demo/src/main/java/com/gxj/cropyield/modules/notification/service/impl/EmailNotificationServiceImpl.java`
- `demo/src/main/java/com/gxj/cropyield/common/mail/EmailSender.java`
- `demo/src/main/java/com/gxj/cropyield/config/AsyncConfig.java`

## 总结
通过将邮件发送改为真正的异步操作（不阻塞等待结果），解决了事务内异步操作导致的回滚问题。这种设计更符合异步编程的最佳实践，提高了系统的健壮性。

---

## 问题2: 审计日志表不存在

### 问题描述
重置密码时出现数据库错误：
```
Table 'database-schema.sys_audit_log' doesn't exist
```

### 根本原因
`UserServiceImpl.updatePassword()` 方法使用了 `@AuditLog` 注解，该注解会自动记录操作日志到 `sys_audit_log` 表，但数据库中缺少这个表。

### 解决方案

#### 方法1: 执行快速修复脚本（推荐）
在你的MySQL数据库中执行 `demo/add_audit_log_table.sql` 文件：

```bash
mysql -u your_username -p database-schema < demo/add_audit_log_table.sql
```

或者在MySQL客户端中直接执行：

```sql
USE `database-schema`;

CREATE TABLE IF NOT EXISTS sys_audit_log (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(100),
    operation VARCHAR(50) NOT NULL,
    module VARCHAR(50) NOT NULL,
    entity_type VARCHAR(100),
    entity_id BIGINT,
    description VARCHAR(500),
    ip_address VARCHAR(50),
    user_agent VARCHAR(500),
    request_uri VARCHAR(200),
    request_method VARCHAR(10),
    request_params TEXT,
    result VARCHAR(20),
    error_message TEXT,
    execution_time BIGINT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    KEY idx_audit_username (username),
    KEY idx_audit_operation (operation),
    KEY idx_audit_module (module),
    KEY idx_audit_created (created_at)
) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COMMENT = '系统审计日志';
```

#### 方法2: 使用Flyway自动迁移
如果你的项目配置了Flyway数据库迁移工具，重启应用即可自动创建表（已创建迁移文件 `V3__add_audit_log_table.sql`）。

#### 方法3: 重新导入完整数据库架构
执行更新后的 `docs/database-schema.sql` 文件（已包含 `sys_audit_log` 表定义）。

### 相关文件
- `demo/add_audit_log_table.sql` - 快速修复脚本
- `demo/src/main/resources/db/migration/V3__add_audit_log_table.sql` - Flyway迁移文件
- `docs/database-schema.sql` - 完整数据库架构（已更新）
- `demo/src/main/java/com/gxj/cropyield/common/audit/AuditLogEntity.java` - 审计日志实体类
- `demo/src/main/java/com/gxj/cropyield/common/audit/AuditLogAspect.java` - 审计日志切面

### 审计日志功能说明
审计日志用于记录系统中的重要操作，包括：
- 用户管理操作（创建、更新、删除、重置密码）
- 数据管理操作（导入、编辑、删除）
- 预测任务操作（创建、执行、删除）
- 报表操作（生成、删除）

记录的信息包括：
- 操作用户、操作类型、模块名称
- 实体类型和ID
- IP地址、用户代理、请求信息
- 操作结果、错误信息、执行时间

这些日志对于安全审计、问题排查和操作追踪非常重要。
