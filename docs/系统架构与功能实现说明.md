# 农作物产量预测系统 - 架构与功能实现说明

**文档版本**: 1.0  
**创建日期**: 2026年1月6日

---

## 目录

1. [系统整体架构](#系统整体架构)
2. [后端技术栈与实现](#后端技术栈与实现)
3. [前端技术栈与实现](#前端技术栈与实现)
4. [核心功能模块](#核心功能模块)
5. [代码位置索引](#代码位置索引)

---

## 系统整体架构

### 架构图

```
┌─────────────────────────────────────────────────────────┐
│                      前端层 (Vue3)                       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │
│  │ 数据管理 │  │ 预测中心 │  │ 可视化   │  │ 用户管理│ │
│  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │
└─────────────────────────────────────────────────────────┘
                          ↕ HTTP/REST API
┌─────────────────────────────────────────────────────────┐
│                   后端层 (Spring Boot)                   │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │
│  │ 控制器层 │  │ 服务层   │  │ 数据层   │  │ 安全层  │ │
│  │Controller│  │ Service  │  │Repository│  │Security │ │
│  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │
└─────────────────────────────────────────────────────────┘
                          ↕ JDBC
┌─────────────────────────────────────────────────────────┐
│                   数据库层 (MySQL)                       │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌─────────┐ │
│  │ 用户表   │  │ 产量表   │  │ 预测表   │  │ 报表表  │ │
│  └──────────┘  └──────────┘  └──────────┘  └─────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 技术栈总览

| 层次 | 技术 | 作用 |
|-----|------|------|
| 前端框架 | Vue 3 | 构建用户界面 |
| 前端构建 | Vite | 快速开发和打包 |
| UI组件库 | Element Plus | 提供现成的UI组件 |
| 图表库 | ECharts | 数据可视化 |
| 后端框架 | Spring Boot | 快速构建REST API |
| 安全框架 | Spring Security + JWT | 认证和授权 |
| 数据库 | MySQL | 数据持久化 |
| ORM框架 | Spring Data JPA | 简化数据库操作 |

---


## 后端技术栈与实现

### 1. Spring Boot - REST接口服务

**是什么**：Spring Boot是一个快速开发框架，用于构建独立的、生产级的Spring应用程序。

**在你的代码中**：
```
demo/
├── src/main/java/com/gxj/cropyield/
│   ├── CropYieldApplication.java          # 应用程序入口
│   └── modules/
│       ├── auth/controller/               # 认证相关接口
│       │   ├── AuthController.java        # 登录、注册接口
│       │   └── UserController.java        # 用户管理接口
│       ├── forecast/controller/           # 预测相关接口
│       │   ├── AsyncForecastController.java    # 异步预测接口
│       │   └── ForecastHistoryController.java  # 预测历史接口
│       ├── yielddata/                     # 产量数据接口
│       │   └── YieldRecordController.java
│       └── report/controller/             # 报表接口
│           └── ReportController.java
```

**REST接口示例**：
```java
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    
    @PostMapping("/login")  // POST /api/auth/login
    public ApiResponse<LoginResponse> login(@RequestBody LoginRequest request) {
        // 处理登录逻辑
    }
    
    @PostMapping("/register")  // POST /api/auth/register
    public ApiResponse<Void> register(@RequestBody RegisterRequest request) {
        // 处理注册逻辑
    }
}
```

**作用**：
- 提供HTTP接口供前端调用
- 处理请求参数和返回JSON响应
- 统一的API路径规范（/api/xxx）

---

### 2. Spring Security + JWT - 登录认证与权限控制

**是什么**：
- **Spring Security**：安全框架，提供认证和授权功能
- **JWT（JSON Web Token）**：一种无状态的身份验证方式

**在你的代码中**：

#### 2.1 Spring Security配置
```
demo/src/main/java/com/gxj/cropyield/config/
└── ApplicationSecurityConfig.java         # 安全配置类
```

**关键代码**：
```java
@Configuration
@EnableWebSecurity
public class ApplicationSecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) {
        http
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/login", "/api/auth/register").permitAll()  // 允许匿名访问
                .requestMatchers("/api/admin/**").hasRole("ADMIN")  // 需要ADMIN角色
                .anyRequest().authenticated()  // 其他请求需要认证
            )
            .addFilterBefore(jwtAuthenticationFilter, ...)  // 添加JWT过滤器
    }
}
```

#### 2.2 JWT实现
```
demo/src/main/java/com/gxj/cropyield/common/security/
├── JwtAuthenticationFilter.java           # JWT过滤器
├── JwtTokenProvider.java                  # JWT生成和验证
└── SecurityContextHelper.java             # 获取当前用户信息
```

**JWT工作流程**：
```
1. 用户登录 → 验证用户名密码
2. 生成JWT Token → 包含用户ID、角色等信息
3. 返回Token给前端 → 前端存储在localStorage
4. 后续请求携带Token → 在Header中: Authorization: Bearer <token>
5. 后端验证Token → 解析出用户信息
6. 检查权限 → 允许或拒绝访问
```

#### 2.3 角色权限
```
demo/src/main/java/com/gxj/cropyield/modules/auth/entity/
├── User.java                              # 用户实体
├── Role.java                              # 角色实体
└── Permission.java                        # 权限实体
```

**三种角色**：
- **ADMIN**：系统管理员，拥有所有权限
- **AGRICULTURE_DEPT**：农业部门用户，可查看和管理数据
- **FARMER**：农户/企业用户，只能查看自己的数据

**作用**：
- 保护API接口，防止未授权访问
- 实现基于角色的访问控制（RBAC）
- 无状态认证，适合分布式系统

---

### 3. MySQL - 数据存储与管理

**是什么**：MySQL是一个关系型数据库，用于持久化存储数据。

**在你的代码中**：

#### 3.1 数据库配置
```
demo/src/main/resources/
└── application.yml                        # 数据库连接配置
```

**配置示例**：
```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/database-schema
    username: root
    password: your_password
  jpa:
    hibernate:
      ddl-auto: update                     # 自动更新表结构
    show-sql: true                         # 显示SQL语句
```

#### 3.2 数据库表结构
```
docs/
└── database-schema.sql                    # 完整的数据库建表脚本
```

**主要数据表**：
```sql
-- 用户相关
sys_user                                   # 用户表
sys_role                                   # 角色表
sys_user_role                              # 用户角色关联表
sys_login_log                              # 登录日志表
sys_audit_log                              # 审计日志表

-- 基础数据
base_region                                # 地区表
base_crop                                  # 作物表

-- 产量数据
dataset_yield_record                       # 产量记录表
data_import_job                            # 数据导入任务表

-- 预测相关
forecast_model                             # 预测模型表
forecast_run                               # 预测执行记录表
forecast_run_series                        # 预测结果时间序列表

-- 报表
report_summary                             # 报表摘要表
```

#### 3.3 数据访问层（Repository）
```
demo/src/main/java/com/gxj/cropyield/modules/
├── auth/repository/
│   ├── UserRepository.java                # 用户数据访问
│   └── RoleRepository.java                # 角色数据访问
├── yielddata/
│   └── YieldRecordRepository.java         # 产量数据访问
└── forecast/repository/
    ├── ForecastModelRepository.java       # 模型数据访问
    └── ForecastRunRepository.java         # 预测记录访问
```

**Repository示例**：
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);  // 根据用户名查找
    List<User> findByRoles_Code(String roleCode);    // 根据角色查找
}
```

**作用**：
- 持久化存储所有业务数据
- 支持复杂查询和事务
- 数据关系管理（外键约束）

---


## 前端技术栈与实现

### 1. Vue 3 - 前端框架

**是什么**：Vue 3是一个渐进式JavaScript框架，用于构建用户界面。

**在你的代码中**：
```
forecast/
├── src/
│   ├── main.js                            # Vue应用入口
│   ├── App.vue                            # 根组件
│   ├── views/                             # 页面组件
│   │   ├── LoginView.vue                  # 登录页面
│   │   ├── DashboardView.vue              # 仪表盘
│   │   ├── DataManagementView.vue         # 数据管理
│   │   ├── ForecastCenterView.vue         # 预测中心
│   │   ├── ForecastVisualizationView.vue  # 可视化
│   │   ├── ReportCenterView.vue           # 报表中心
│   │   └── UserManagementView.vue         # 用户管理
│   └── components/                        # 可复用组件
│       ├── data/                          # 数据管理组件
│       ├── forecast/                      # 预测相关组件
│       └── visualization/                 # 可视化组件
```

**Vue组件示例**：
```vue
<template>
  <div class="data-management">
    <h1>数据管理</h1>
    <el-button @click="handleUpload">上传数据</el-button>
    <el-table :data="tableData">
      <el-table-column prop="year" label="年份" />
      <el-table-column prop="yield" label="产量" />
    </el-table>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import { fetchYieldData } from '@/services/data'

const tableData = ref([])

onMounted(async () => {
  tableData.value = await fetchYieldData()
})
</script>
```

**作用**：
- 组件化开发，代码可复用
- 响应式数据绑定，自动更新UI
- 单页应用（SPA），无需刷新页面

---

### 2. Vite - 构建工具

**是什么**：Vite是新一代前端构建工具，提供极速的开发体验。

**在你的代码中**：
```
forecast/
├── vite.config.js                         # Vite配置文件
├── package.json                           # 项目依赖配置
└── index.html                             # HTML入口文件
```

**配置示例**：
```javascript
export default defineConfig({
  plugins: [vue()],
  server: {
    port: 5173,                            # 开发服务器端口
    proxy: {
      '/api': {
        target: 'http://localhost:8080',   # 代理到后端
        changeOrigin: true
      }
    }
  }
})
```

**作用**：
- 快速启动开发服务器（热更新）
- 打包优化，生成生产环境代码
- 代理API请求，解决跨域问题

---

### 3. Element Plus - UI组件库

**是什么**：Element Plus是基于Vue 3的组件库，提供丰富的UI组件。

**在你的代码中**：
```
forecast/src/
├── main.js                                # 引入Element Plus
└── views/                                 # 使用Element Plus组件
```

**使用示例**：
```vue
<template>
  <!-- 表格组件 -->
  <el-table :data="tableData" border>
    <el-table-column prop="name" label="名称" />
  </el-table>
  
  <!-- 按钮组件 -->
  <el-button type="primary" @click="handleClick">提交</el-button>
  
  <!-- 对话框组件 -->
  <el-dialog v-model="dialogVisible" title="提示">
    <span>这是一段信息</span>
  </el-dialog>
  
  <!-- 表单组件 -->
  <el-form :model="form" :rules="rules">
    <el-form-item label="用户名" prop="username">
      <el-input v-model="form.username" />
    </el-form-item>
  </el-form>
</template>
```

**常用组件**：
- `el-table`：数据表格
- `el-form`：表单
- `el-button`：按钮
- `el-dialog`：对话框
- `el-select`：下拉选择
- `el-date-picker`：日期选择
- `el-upload`：文件上传
- `el-message`：消息提示

**作用**：
- 提供现成的UI组件，无需从零开发
- 统一的设计风格
- 响应式布局，适配不同屏幕

---

### 4. ECharts - 数据可视化

**是什么**：ECharts是百度开源的图表库，支持丰富的图表类型。

**在你的代码中**：
```
forecast/src/
├── components/charts/
│   └── BaseChart.vue                      # ECharts封装组件
└── views/
    ├── DashboardView.vue                  # 仪表盘图表
    └── ForecastVisualizationView.vue      # 预测可视化图表
```

**BaseChart组件**：
```vue
<template>
  <div ref="chartRef" :style="{ height: height + 'px' }"></div>
</template>

<script setup>
import * as echarts from 'echarts'
import { ref, onMounted, watch } from 'vue'

const props = defineProps({
  option: Object,                          # 图表配置
  height: { type: Number, default: 400 }
})

const chartRef = ref(null)
let chartInstance = null

onMounted(() => {
  chartInstance = echarts.init(chartRef.value)
  chartInstance.setOption(props.option)
})

watch(() => props.option, (newOption) => {
  chartInstance.setOption(newOption)
})
</script>
```

**图表配置示例**：
```javascript
const chartOption = {
  title: { text: '产量趋势图' },
  tooltip: { trigger: 'axis' },
  legend: { data: ['实际产量', '预测产量'] },
  xAxis: {
    type: 'category',
    data: ['2020', '2021', '2022', '2023', '2024']
  },
  yAxis: {
    type: 'value',
    name: '产量(吨)'
  },
  series: [
    {
      name: '实际产量',
      type: 'line',
      data: [6.5, 6.8, 6.3, 7.0, null]
    },
    {
      name: '预测产量',
      type: 'line',
      data: [null, null, null, null, 7.2]
    }
  ]
}
```

**支持的图表类型**：
- 折线图（line）：展示趋势
- 柱状图（bar）：对比数据
- 饼图（pie）：展示占比
- 散点图（scatter）：展示分布
- 地图（map）：地理分布

**在你的系统中的应用**：
```
forecast/src/views/
├── DashboardView.vue
│   ├── 产量统计柱状图
│   ├── 地区分布饼图
│   └── 趋势折线图
└── ForecastVisualizationView.vue
    ├── 历史vs预测对比图
    ├── 多模型对比图
    └── 地区产量地图
```

**作用**：
- 将数据转化为直观的图表
- 支持交互（缩放、筛选、提示）
- 响应式图表，自适应容器大小

---


## 核心功能模块

### 1. 数据集导入与管理

**功能描述**：支持Excel文件上传，导入历史产量数据，并提供数据的增删改查功能。

#### 后端实现位置
```
demo/src/main/java/com/gxj/cropyield/
├── dataimport/                            # 数据导入模块
│   ├── controller/
│   │   └── DataImportController.java      # 文件上传接口
│   ├── service/
│   │   └── DataImportService.java         # 导入逻辑处理
│   └── entity/
│       └── DataImportJob.java             # 导入任务实体
└── yielddata/                             # 产量数据管理
    ├── YieldRecordController.java         # CRUD接口
    ├── YieldRecordService.java            # 业务逻辑
    └── YieldRecordRepository.java         # 数据访问
```

#### 前端实现位置
```
forecast/src/
├── views/
│   └── DataManagementView.vue             # 数据管理主页面
└── components/data/
    ├── DataUploadPanel.vue                # 文件上传组件
    ├── DataTableView.vue                  # 数据表格展示
    ├── DataEditDialog.vue                 # 数据编辑对话框
    └── DataStatisticsCard.vue             # 数据统计卡片
```

#### 工作流程
```
1. 用户上传Excel文件
   ↓
2. 后端解析Excel，验证数据格式
   ↓
3. 批量插入数据库（dataset_yield_record表）
   ↓
4. 返回导入结果（成功/失败/警告）
   ↓
5. 前端刷新数据列表，显示导入的数据
```

#### 关键代码
```java
@PostMapping("/import")
public ApiResponse<ImportResult> importData(@RequestParam("file") MultipartFile file) {
    // 1. 验证文件格式
    if (!file.getOriginalFilename().endsWith(".xlsx")) {
        throw new BusinessException("只支持Excel文件");
    }
    
    // 2. 解析Excel
    List<YieldRecord> records = excelParser.parse(file);
    
    // 3. 数据验证
    validateRecords(records);
    
    // 4. 批量保存
    yieldRecordRepository.saveAll(records);
    
    return ApiResponse.success(new ImportResult(records.size()));
}
```

---

### 2. 模型参数配置

**功能描述**：为不同的预测模型配置参数，如LSTM的隐藏层大小、ARIMA的p/d/q参数等。

#### 后端实现位置
```
demo/src/main/java/com/gxj/cropyield/modules/forecast/
├── entity/
│   └── ForecastModel.java                 # 模型实体（包含默认参数）
├── engine/
│   ├── Dl4jLstmForecaster.java           # LSTM实现（接受参数）
│   ├── ArimaForecaster.java              # ARIMA实现（接受参数）
│   ├── ProphetForecaster.java            # Prophet实现（接受参数）
│   └── LocalForecastEngine.java          # 天气回归实现（接受参数）
```

#### 前端实现位置
```
forecast/src/
├── views/
│   └── ForecastCenterView.vue             # 预测中心主页面
└── components/forecast/
    ├── ModelSelectionPanel.vue            # 模型选择面板
    └── ParameterConfigForm.vue            # 参数配置表单
```

#### 可配置参数

**LSTM模型**：
```javascript
{
  learningRate: 0.001,      // 学习率
  hiddenSize: 32,           // 隐藏层大小
  epochs: 20,               // 训练轮数
  dropout: 0.1,             // Dropout比例
  seed: 42                  // 随机种子
}
```

**ARIMA模型**：
```javascript
{
  p: 1,                     // AR阶数
  d: 1,                     // 差分阶数
  q: 1                      // MA阶数
}
```

**Prophet模型**：
```javascript
{
  changepointPriorScale: 0.05,      // 变点先验尺度
  seasonalityPriorScale: 10.0,      // 季节性先验尺度
  seasonalityPeriod: 0              // 季节周期（0=自动检测）
}
```

**天气回归模型**：
```javascript
{
  futureWeatherFeatures: {          // 未来气象数据
    2024: {
      avgTemp: 25.0,
      totalPrecip: 1200,
      totalSunshine: 1800
    }
  }
}
```

#### 参数传递流程
```
前端表单 → JSON对象 → HTTP请求 → 后端Controller → Service → Engine
```

---

### 3. 预测任务创建与执行

**功能描述**：创建预测任务，选择模型、地区、作物，执行预测并保存结果。

#### 后端实现位置
```
demo/src/main/java/com/gxj/cropyield/modules/forecast/
├── controller/
│   └── AsyncForecastController.java       # 异步预测接口
├── service/
│   ├── AsyncForecastService.java          # 预测任务管理
│   └── ForecastExecutionService.java      # 预测执行逻辑
├── engine/
│   └── LocalForecastEngine.java           # 预测引擎核心
└── entity/
    ├── AsyncForecastTask.java             # 预测任务实体
    └── ForecastRun.java                   # 预测执行记录
```

#### 前端实现位置
```
forecast/src/
├── views/
│   └── ForecastCenterView.vue             # 预测中心
└── components/forecast/
    ├── HistoryDataSelector.vue            # 历史数据选择
    ├── ModelSelectionPanel.vue            # 模型选择
    ├── ParameterConfigForm.vue            # 参数配置
    ├── ForecastTaskList.vue               # 任务列表
    └── ResultPreviewCard.vue              # 结果预览
```

#### 预测流程
```
1. 用户选择：
   - 地区（如：德宏傣族景颇族自治州）
   - 作物（如：稻谷）
   - 模型（如：LSTM）
   - 预测期数（如：3年）
   - 参数配置
   ↓
2. 创建预测任务（POST /api/forecast/tasks）
   ↓
3. 后端异步执行：
   - 查询历史数据
   - 数据预处理
   - 调用预测引擎
   - 计算评估指标
   ↓
4. 保存预测结果到数据库
   ↓
5. 前端轮询任务状态，显示进度
   ↓
6. 任务完成，展示预测结果
```

#### 关键代码
```java
@PostMapping("/tasks")
public ApiResponse<TaskResponse> createTask(@RequestBody TaskRequest request) {
    // 1. 创建任务
    AsyncForecastTask task = new AsyncForecastTask();
    task.setStatus(TaskStatus.PENDING);
    taskRepository.save(task);
    
    // 2. 异步执行
    CompletableFuture.runAsync(() -> {
        try {
            // 查询历史数据
            List<YieldRecord> history = yieldRecordRepository.findByRegionAndCrop(...);
            
            // 执行预测
            ForecastResult result = forecastEngine.forecast(history, request.getModel(), ...);
            
            // 保存结果
            saveForecastResult(result);
            
            // 更新任务状态
            task.setStatus(TaskStatus.COMPLETED);
        } catch (Exception e) {
            task.setStatus(TaskStatus.FAILED);
        }
        taskRepository.save(task);
    });
    
    return ApiResponse.success(new TaskResponse(task.getId()));
}
```

---

### 4. 结果对比分析

**功能描述**：对比不同模型的预测结果，分析各模型的优劣。

#### 后端实现位置
```
demo/src/main/java/com/gxj/cropyield/modules/forecast/
├── controller/
│   └── ForecastHistoryController.java     # 预测历史查询接口
├── service/
│   └── ForecastHistoryService.java        # 历史数据聚合
└── dto/
    └── ForecastHistoryResponse.java       # 预测结果DTO
```

#### 前端实现位置
```
forecast/src/
└── views/
    └── ForecastVisualizationView.vue      # 可视化对比页面
```

#### 对比维度
```
1. 按模型对比：
   - LSTM vs ARIMA vs Prophet vs 天气回归
   - 同一地区、同一作物、不同模型的预测结果
   
2. 按地区对比：
   - 德宏州 vs 临沧市 vs 曲靖市
   - 同一模型、同一作物、不同地区的预测结果
   
3. 按作物对比：
   - 稻谷 vs 小麦 vs 玉米
   - 同一模型、同一地区、不同作物的预测结果
```

#### 可视化展示
```
forecast/src/views/ForecastVisualizationView.vue
├── 折线图：展示多个模型的预测趋势
├── 柱状图：对比不同模型的预测值
├── 表格：详细的数值对比
└── 统计卡片：最高值、最低值、平均值
```

---

### 5. 报表导出

**功能描述**：将预测结果导出为PDF或Excel报表，包含图表和数据分析。

#### 后端实现位置
```
demo/src/main/java/com/gxj/cropyield/modules/report/
├── controller/
│   └── ReportController.java              # 报表生成接口
├── service/
│   └── ReportService.java                 # 报表生成逻辑
└── entity/
    └── ReportSummary.java                 # 报表实体
```

#### 前端实现位置
```
forecast/src/
└── views/
    └── ReportCenterView.vue               # 报表中心
```

#### 报表内容
```
1. 报表标题和基本信息
   - 生成时间
   - 地区、作物
   - 预测模型
   
2. 预测结果摘要
   - 预测值列表
   - 评估指标（R²、RMSE、MAE、MAPE）
   
3. 可视化图表
   - 历史vs预测趋势图
   - 模型对比图
   
4. 数据分析
   - 趋势分析
   - 风险评估
   - 建议措施
```

#### 导出流程
```
1. 用户点击"生成报表"
   ↓
2. 选择报表类型（PDF/Excel）
   ↓
3. 后端查询预测数据
   ↓
4. 生成报表文件
   ↓
5. 返回文件下载链接
   ↓
6. 前端触发文件下载
```

---

### 6. 模型效果评价

**功能描述**：使用多个指标评估预测模型的准确性和可靠性。

#### 评估指标实现位置
```
demo/src/main/java/com/gxj/cropyield/modules/forecast/
├── engine/
│   └── LocalForecastEngine.java           # 评估指标计算
└── dto/
    └── ForecastEngineResponse.java        # 包含评估指标
```

#### 四大评估指标

**1. R²（决定系数）**
```java
// 代码位置：LocalForecastEngine.java
double calculateR2(List<Double> actual, List<Double> predicted) {
    double mean = actual.stream().mapToDouble(Double::doubleValue).average().orElse(0);
    double ssTot = actual.stream().mapToDouble(v -> Math.pow(v - mean, 2)).sum();
    double ssRes = 0;
    for (int i = 0; i < actual.size(); i++) {
        ssRes += Math.pow(actual.get(i) - predicted.get(i), 2);
    }
    return 1 - (ssRes / ssTot);
}
```
- **含义**：模型解释了多少数据变异
- **范围**：-∞ 到 1
- **解释**：
  - R² = 1：完美预测
  - R² = 0.8：解释了80%的变异，效果好
  - R² = 0：模型无效
  - R² < 0：比平均值还差

**2. RMSE（均方根误差）**
```java
double calculateRMSE(List<Double> actual, List<Double> predicted) {
    double sumSquaredError = 0;
    for (int i = 0; i < actual.size(); i++) {
        double error = actual.get(i) - predicted.get(i);
        sumSquaredError += error * error;
    }
    return Math.sqrt(sumSquaredError / actual.size());
}
```
- **含义**：预测值与实际值的平均偏差
- **单位**：与原数据相同（如吨/公顷）
- **解释**：值越小越好，0表示完美预测

**3. MAE（平均绝对误差）**
```java
double calculateMAE(List<Double> actual, List<Double> predicted) {
    double sumAbsError = 0;
    for (int i = 0; i < actual.size(); i++) {
        sumAbsError += Math.abs(actual.get(i) - predicted.get(i));
    }
    return sumAbsError / actual.size();
}
```
- **含义**：预测误差的平均绝对值
- **单位**：与原数据相同
- **解释**：比RMSE更直观，不受极端值影响

**4. MAPE（平均绝对百分比误差）**
```java
double calculateMAPE(List<Double> actual, List<Double> predicted) {
    double sumPercentError = 0;
    for (int i = 0; i < actual.size(); i++) {
        if (actual.get(i) != 0) {
            sumPercentError += Math.abs((actual.get(i) - predicted.get(i)) / actual.get(i));
        }
    }
    return (sumPercentError / actual.size()) * 100;
}
```
- **含义**：预测误差占实际值的百分比
- **单位**：百分比（%）
- **解释**：
  - MAPE < 10%：预测精度高
  - MAPE < 20%：预测精度良好
  - MAPE > 50%：预测精度差

#### 前端展示位置
```
forecast/src/
├── views/
│   ├── ForecastCenterView.vue             # 预测结果卡片显示指标
│   └── ForecastVisualizationView.vue      # 可视化页面显示指标
└── components/forecast/
    └── ResultPreviewCard.vue              # 结果预览卡片
```

---


## 代码位置索引

### 完整的目录结构映射

#### 后端（demo/）

```
demo/
├── src/main/java/com/gxj/cropyield/
│   ├── CropYieldApplication.java                    # 【应用入口】Spring Boot启动类
│   │
│   ├── config/                                      # 【配置层】系统配置
│   │   ├── ApplicationSecurityConfig.java           # Spring Security配置
│   │   ├── AsyncConfig.java                         # 异步任务配置
│   │   ├── CacheConfig.java                         # 缓存配置
│   │   └── CorsConfig.java                          # 跨域配置
│   │
│   ├── common/                                      # 【公共层】通用组件
│   │   ├── response/
│   │   │   ├── ApiResponse.java                     # 统一响应格式
│   │   │   └── ResultCode.java                      # 响应状态码
│   │   ├── exception/
│   │   │   ├── BusinessException.java               # 业务异常
│   │   │   └── GlobalExceptionHandler.java          # 全局异常处理
│   │   ├── security/
│   │   │   ├── JwtAuthenticationFilter.java         # JWT过滤器
│   │   │   ├── JwtTokenProvider.java                # JWT生成和验证
│   │   │   └── SecurityContextHelper.java           # 获取当前用户
│   │   ├── audit/
│   │   │   ├── AuditLogAspect.java                  # 审计日志切面
│   │   │   ├── AuditLogEntity.java                  # 审计日志实体
│   │   │   └── AuditLogRepository.java              # 审计日志数据访问
│   │   └── mail/
│   │       └── EmailSender.java                     # 邮件发送
│   │
│   ├── modules/                                     # 【业务模块层】
│   │   │
│   │   ├── auth/                                    # 【认证模块】用户认证和授权
│   │   │   ├── controller/
│   │   │   │   ├── AuthController.java              # 登录、注册接口
│   │   │   │   └── UserController.java              # 用户管理接口
│   │   │   ├── service/
│   │   │   │   ├── AuthService.java                 # 认证业务逻辑
│   │   │   │   ├── UserService.java                 # 用户管理逻辑
│   │   │   │   └── PasswordResetService.java        # 密码重置逻辑
│   │   │   ├── repository/
│   │   │   │   ├── UserRepository.java              # 用户数据访问
│   │   │   │   └── RoleRepository.java              # 角色数据访问
│   │   │   ├── entity/
│   │   │   │   ├── User.java                        # 用户实体
│   │   │   │   ├── Role.java                        # 角色实体
│   │   │   │   └── Permission.java                  # 权限实体
│   │   │   └── dto/
│   │   │       ├── LoginRequest.java                # 登录请求DTO
│   │   │       ├── LoginResponse.java               # 登录响应DTO
│   │   │       └── UserResponse.java                # 用户信息DTO
│   │   │
│   │   ├── yielddata/                               # 【产量数据模块】
│   │   │   ├── YieldRecordController.java           # 产量数据CRUD接口
│   │   │   ├── YieldRecordService.java              # 产量数据业务逻辑
│   │   │   ├── YieldRecordRepository.java           # 产量数据访问
│   │   │   └── YieldRecord.java                     # 产量记录实体
│   │   │
│   │   ├── dataimport/                              # 【数据导入模块】
│   │   │   ├── controller/
│   │   │   │   └── DataImportController.java        # 文件上传接口
│   │   │   ├── service/
│   │   │   │   └── DataImportService.java           # 导入逻辑处理
│   │   │   ├── entity/
│   │   │   │   ├── DataImportJob.java               # 导入任务实体
│   │   │   │   └── DataImportJobError.java          # 导入错误记录
│   │   │   └── parser/
│   │   │       └── ExcelParser.java                 # Excel解析器
│   │   │
│   │   ├── forecast/                                # 【预测模块】核心预测功能
│   │   │   ├── controller/
│   │   │   │   ├── AsyncForecastController.java     # 异步预测接口
│   │   │   │   └── ForecastHistoryController.java   # 预测历史查询接口
│   │   │   ├── service/
│   │   │   │   ├── AsyncForecastService.java        # 预测任务管理
│   │   │   │   ├── ForecastExecutionService.java    # 预测执行逻辑
│   │   │   │   └── ForecastHistoryService.java      # 历史数据聚合
│   │   │   ├── engine/                              # 【预测引擎】算法实现
│   │   │   │   ├── LocalForecastEngine.java         # 预测引擎核心
│   │   │   │   ├── Dl4jLstmForecaster.java         # LSTM算法实现
│   │   │   │   ├── ArimaForecaster.java            # ARIMA算法实现
│   │   │   │   ├── ProphetForecaster.java          # Prophet算法实现
│   │   │   │   └── LagFeatureEnhancer.java         # 特征工程
│   │   │   ├── entity/
│   │   │   │   ├── ForecastModel.java               # 预测模型实体
│   │   │   │   ├── ForecastRun.java                 # 预测执行记录
│   │   │   │   ├── ForecastRunSeries.java           # 预测结果时间序列
│   │   │   │   └── AsyncForecastTask.java           # 异步预测任务
│   │   │   ├── repository/
│   │   │   │   ├── ForecastModelRepository.java     # 模型数据访问
│   │   │   │   └── ForecastRunRepository.java       # 预测记录访问
│   │   │   └── dto/
│   │   │       ├── ForecastEngineRequest.java       # 预测请求DTO
│   │   │       ├── ForecastEngineResponse.java      # 预测响应DTO
│   │   │       └── ForecastHistoryResponse.java     # 历史记录DTO
│   │   │
│   │   ├── report/                                  # 【报表模块】
│   │   │   ├── controller/
│   │   │   │   └── ReportController.java            # 报表生成接口
│   │   │   ├── service/
│   │   │   │   └── ReportService.java               # 报表生成逻辑
│   │   │   ├── entity/
│   │   │   │   └── ReportSummary.java               # 报表实体
│   │   │   └── generator/
│   │   │       ├── PdfReportGenerator.java          # PDF生成器
│   │   │       └── ExcelReportGenerator.java        # Excel生成器
│   │   │
│   │   ├── dashboard/                               # 【仪表盘模块】
│   │   │   ├── DashboardController.java             # 仪表盘数据接口
│   │   │   └── DashboardService.java                # 统计数据聚合
│   │   │
│   │   └── notification/                            # 【通知模块】
│   │       ├── service/
│   │       │   └── EmailNotificationService.java    # 邮件通知服务
│   │       └── dto/
│   │           └── EmailNotificationRequest.java    # 邮件通知请求
│   │
│   └── resources/                                   # 【资源文件】
│       ├── application.yml                          # 应用配置文件
│       ├── logback-spring.xml                       # 日志配置
│       └── db/migration/                            # 数据库迁移脚本
│           ├── V1__initial_schema.sql               # 初始化脚本
│           ├── V2__add_performance_indexes.sql      # 性能优化索引
│           └── V3__add_audit_log_table.sql          # 审计日志表
│
└── pom.xml                                          # Maven依赖配置
```

#### 前端（forecast/）

```
forecast/
├── src/
│   ├── main.js                                      # 【应用入口】Vue应用初始化
│   ├── App.vue                                      # 【根组件】应用根组件
│   │
│   ├── router/                                      # 【路由配置】
│   │   └── index.js                                 # 路由定义
│   │
│   ├── stores/                                      # 【状态管理】Pinia stores
│   │   └── auth.js                                  # 用户认证状态
│   │
│   ├── services/                                    # 【API服务层】
│   │   ├── http.js                                  # HTTP客户端配置
│   │   ├── auth.js                                  # 认证API
│   │   ├── data.js                                  # 数据管理API
│   │   ├── forecast.js                              # 预测API
│   │   └── report.js                                # 报表API
│   │
│   ├── views/                                       # 【页面组件】
│   │   ├── LoginView.vue                            # 登录页面
│   │   ├── DashboardView.vue                        # 仪表盘
│   │   ├── DataManagementView.vue                   # 数据管理页面
│   │   ├── ForecastCenterView.vue                   # 预测中心页面
│   │   ├── ForecastVisualizationView.vue            # 预测可视化页面
│   │   ├── ReportCenterView.vue                     # 报表中心页面
│   │   ├── UserManagementView.vue                   # 用户管理页面
│   │   ├── PersonalCenterView.vue                   # 个人中心页面
│   │   └── LogManagementView.vue                    # 日志管理页面
│   │
│   ├── components/                                  # 【可复用组件】
│   │   ├── layout/                                  # 布局组件
│   │   │   ├── AppHeader.vue                        # 顶部导航栏
│   │   │   ├── AppSidebar.vue                       # 侧边栏
│   │   │   └── AppFooter.vue                        # 页脚
│   │   │
│   │   ├── charts/                                  # 图表组件
│   │   │   └── BaseChart.vue                        # ECharts封装
│   │   │
│   │   ├── data/                                    # 数据管理组件
│   │   │   ├── DataUploadPanel.vue                  # 文件上传面板
│   │   │   ├── DataTableView.vue                    # 数据表格
│   │   │   ├── DataEditDialog.vue                   # 数据编辑对话框
│   │   │   └── DataStatisticsCard.vue               # 数据统计卡片
│   │   │
│   │   ├── forecast/                                # 预测相关组件
│   │   │   ├── ModelSelectionPanel.vue              # 模型选择面板
│   │   │   ├── ParameterConfigForm.vue              # 参数配置表单
│   │   │   ├── HistoryDataSelector.vue              # 历史数据选择器
│   │   │   ├── ForecastTaskList.vue                 # 预测任务列表
│   │   │   └── ResultPreviewCard.vue                # 结果预览卡片
│   │   │
│   │   └── visualization/                           # 可视化组件
│   │       ├── TrendChart.vue                       # 趋势图
│   │       ├── MapChart.vue                         # 地图
│   │       ├── StructureChart.vue                   # 结构图
│   │       ├── HeroStatsCard.vue                    # 统计卡片
│   │       ├── DataFilterPanel.vue                  # 数据筛选面板
│   │       └── SmartRecommendationPanel.vue         # 智能推荐面板
│   │
│   ├── assets/                                      # 【静态资源】
│   │   ├── styles/                                  # 样式文件
│   │   └── images/                                  # 图片资源
│   │
│   └── utils/                                       # 【工具函数】
│       ├── format.js                                # 格式化工具
│       └── validation.js                            # 验证工具
│
├── public/                                          # 【公共资源】
│   └── favicon.ico                                  # 网站图标
│
├── index.html                                       # HTML入口
├── vite.config.js                                   # Vite配置
└── package.json                                     # 项目依赖
```

---

## 技术术语解释

### 1. REST API
**全称**：Representational State Transfer Application Programming Interface  
**中文**：表述性状态转移应用程序接口  
**通俗解释**：一种设计风格，用HTTP方法（GET、POST、PUT、DELETE）操作资源

**示例**：
```
GET    /api/users          # 获取用户列表
POST   /api/users          # 创建新用户
PUT    /api/users/1        # 更新ID为1的用户
DELETE /api/users/1        # 删除ID为1的用户
```

### 2. JWT (JSON Web Token)
**中文**：JSON网络令牌  
**通俗解释**：一种加密的字符串，包含用户信息，用于身份验证

**结构**：
```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEsInVzZXJuYW1lIjoiYWRtaW4ifQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
    ↑ Header（头部）          ↑ Payload（载荷）                    ↑ Signature（签名）
```

### 3. ORM (Object-Relational Mapping)
**中文**：对象关系映射  
**通俗解释**：将数据库表映射为Java对象，用面向对象的方式操作数据库

**示例**：
```java
// 不用写SQL
User user = userRepository.findById(1);  // 自动生成：SELECT * FROM sys_user WHERE id = 1

// 保存对象
user.setEmail("new@email.com");
userRepository.save(user);  // 自动生成：UPDATE sys_user SET email = 'new@email.com' WHERE id = 1
```

### 4. DTO (Data Transfer Object)
**中文**：数据传输对象  
**通俗解释**：用于在不同层之间传输数据的简单对象

**为什么需要DTO**：
- 实体类（Entity）包含数据库字段，可能有敏感信息（如密码）
- DTO只包含需要传输的字段，更安全
- 可以组合多个实体的数据

**示例**：
```java
// Entity（数据库实体）
public class User {
    private Long id;
    private String username;
    private String password;  // 敏感信息
    private String email;
}

// DTO（传输对象）
public class UserResponse {
    private Long id;
    private String username;
    private String email;
    // 不包含password
}
```

### 5. 响应式数据绑定
**通俗解释**：数据变化时，UI自动更新

**Vue 3示例**：
```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)  // 响应式数据

function increment() {
  count.value++  // 数据变化
}
</script>

<template>
  <div>{{ count }}</div>  <!-- UI自动更新 -->
  <button @click="increment">+1</button>
</template>
```

### 6. 单页应用（SPA）
**全称**：Single Page Application  
**通俗解释**：整个应用只有一个HTML页面，通过JavaScript动态更新内容，无需刷新页面

**传统多页应用 vs SPA**：
```
传统：
首页 → 点击链接 → 刷新页面 → 加载新页面

SPA：
首页 → 点击链接 → 不刷新 → JavaScript更新内容
```

---

## 总结

你的系统是一个**前后端分离**的Web应用：

**后端（Spring Boot）**：
- 提供REST API接口
- 处理业务逻辑（预测、数据管理等）
- 管理数据库
- 实现安全认证

**前端（Vue 3）**：
- 提供用户界面
- 调用后端API
- 展示数据和图表
- 处理用户交互

**数据流**：
```
用户操作 → 前端Vue组件 → HTTP请求 → 后端Controller → Service → Repository → MySQL
                                                                              ↓
用户看到结果 ← 前端更新UI ← HTTP响应 ← Controller ← Service ← Repository ← 查询结果
```

这种架构的优点：
- 前后端独立开发和部署
- 前端可以复用后端API
- 易于扩展和维护
- 支持多端（Web、移动端）

